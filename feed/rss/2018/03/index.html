<?xml version="1.0" encoding="UTF-8"?>
<rdf:RDF
xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
xmlns="http://purl.org/rss/1.0/"
xmlns:dc="http://purl.org/dc/elements/1.1/">
<channel rdf:about="https://feelncut.com/feed/rss/2018/03/">
<title>小王同学 - 2018年3月</title>
<link>https://feelncut.com/2018/03/</link>
<description>希望通过自我加工，成为有点用的人</description>
<items>
<rdf:Seq>
<rdf:li resource="https://feelncut.com/2018/03/22/109.html"/>
<rdf:li resource="https://feelncut.com/2018/03/22/107.html"/>
<rdf:li resource="https://feelncut.com/2018/03/09/knn.html"/>
<rdf:li resource="https://feelncut.com/2018/03/08/perceptron.html"/>
<rdf:li resource="https://feelncut.com/2018/03/06/104.html"/>
<rdf:li resource="https://feelncut.com/2018/03/05/103.html"/>
<rdf:li resource="https://feelncut.com/2018/03/05/102.html"/>
<rdf:li resource="https://feelncut.com/2018/03/05/101.html"/>
<rdf:li resource="https://feelncut.com/2018/03/01/99.html"/>
<rdf:li resource="https://feelncut.com/2018/03/01/98.html"/>
</rdf:Seq>
</items>
</channel>
<item rdf:about="https://feelncut.com/2018/03/22/109.html">
<title>Latex速查</title>
<link>https://feelncut.com/2018/03/22/109.html</link>
<dc:date>2018-03-22T11:28:44+08:00</dc:date>
<description>转自[一份不太简短的 LATEX2e 介绍](http://www.mohu.org/info/lshort-cn.pdf "一份不太简短的 LATEX2e 介绍")


[latex.pdf](https://image.feelncut.com/2018/03/1734916613.pdf)</description>
</item>
<item rdf:about="https://feelncut.com/2018/03/22/107.html">
<title>对于朴素贝叶斯算法的理解</title>
<link>https://feelncut.com/2018/03/22/107.html</link>
<dc:date>2018-03-22T11:25:00+08:00</dc:date>
<description>[TOC]

### 算法的基础
贝叶斯定理：已知P(B|A)求P(A|B)。公式：
```math
P(A|B)= \frac {P(A)\times P(B|A)}{P(B)}
```

### 何来朴素

因为对所有条件概率分布作了条件独立性的假设，目的是简化计算量。

### 极大似然估计与贝叶斯估计

前者可能出现$$P(B_i|A)=0$$的情况，此时会影响到后验概率的计算结果，使分类产生偏差，不能很好的你和测试集。所以引出了贝叶斯估计。拉普拉斯平滑是条件概率贝叶斯估计的一个特例（$$\lambda=1$$）</description>
</item>
<item rdf:about="https://feelncut.com/2018/03/09/knn.html">
<title>对于K近邻K-NN算法的理解</title>
<link>https://feelncut.com/2018/03/09/knn.html</link>
<dc:date>2018-03-09T16:15:00+08:00</dc:date>
<description>[TOC]

### 整体思想

今天看了K-NN算法，该算法适用于分类，整体思想是把训练数据集当成了一个数据库，在训练数据集找与输入数据最临近的k个数据，这k个数据中的多数属于某个类，这个输入就输入某个类。特别地， k=1 是称为最近邻算法。

### 如何定义近邻

可以用欧氏距离，$$L_p$$距离，Minkowski距离等。

### k值的选择

k太小，学习的近似误差会减小，估计误差会增大，比如遇到噪声，这时候容易发生过拟合。

k过大，会增加不相近的数据对输入的干扰，虽然增大了学习的近似误差，但是减少了估计误差，k的增大意味着整体模型变得简单。

k=N，对于一个输入用上了全部数据，不可取。

### 分类决策规则

多数投票表决规则等价于经验风险最小化，除了投票还有求均值等规则。

### 实现

书上介绍通过kd树实现训练数据存储，然后在kd树上查找最近邻。除了kd树还有很多优化算法。</description>
</item>
<item rdf:about="https://feelncut.com/2018/03/08/perceptron.html">
<title>对于感知机Perceptron算法的理解</title>
<link>https://feelncut.com/2018/03/08/perceptron.html</link>
<dc:date>2018-03-08T17:01:00+08:00</dc:date>
<description>[TOC]

# 算法的适用范围

目标二分类，数据集线性可分。之所以不能学习XOR是因为XOR线性不可分。

# 几何意义

特征空间$$R^n$$中的一个超平面$$S$$将特征空间划分为两个部分。这两个部分分别代表两类。这个超平面称为**分离超平面**。

# 学习策略

感知机的损失函数由误分类点到超平面的距离之后推出，根据空间点到面的距离得到损失函数。

# 原始形式和对偶形式的区别

感知机学习算法分为原始形式和对偶形式，我的理解是原始形式和对偶形式本质上是一样的（废话），不同点在于计算顺序不同。假定处理高维数据，对偶形式的好处为可以首先并行计算出Gram矩阵，然后通过查表更新参数。而原始形式串行处理每组数据进行更新参数。

知乎的[这个](https://www.zhihu.com/question/26526858 "这个")答案解释的有点过了吧。

# 收敛性证明

收敛性证明的思路为递推缩放，主要是推导以下两个不等式。
```latex
||\hat{W}_k|| \cdot ||\hat{W}_{opt}||\leq k \eta \gamma  
```
```math
||\hat{W}_k||^2 \leq k \eta^2 R^2
```


# 多解的原因

- 初值不同
- 误分类点出现顺序不同

# 代码

通过`sklearn`实现：[Github](https://github.com/wangke0809/learn-statistical-learning-method/blob/master/Perceptron.py)</description>
</item>
<item rdf:about="https://feelncut.com/2018/03/06/104.html">
<title>投票私链交付文档</title>
<link>https://feelncut.com/2018/03/06/104.html</link>
<dc:date>2018-03-06T21:42:00+08:00</dc:date>
<description>
[TOC]

### 环境要求

开发环境：
Ubuntu 16.04
Python 3.5+
PM2

创世区块分配钱包地址为：`0x4a244BF6834f7569A726DB8ec0D3B24D31ce52c3`
私钥为：`0x4a115bf4ec4e27fce40db37c974d526953e50cc5c1edbffef3f724062fcb01c7`

### 环境安装

#### 安装PM2

PM2用于管理Geth和Web API后台进程。
**参考安装方式**：通过 nvm 安装 NodeJS

```
curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.32.1/install.sh | bash
source ~/.bashrc
nvm install v6.9.1
npm install -g pm2
```

#### 安装Python环境

安装Web API 必须环境：

安装时注意python应使用python3，如果系统带有python2.7和python3.5，下面命令应使用`python3`。

```
# python 包管理器pip
sudo apt-get python3-pip
sudo pip install --upgrade pip
# python web framework
sudo pip install flask
# python web server
sudo pip install gunicorn
# install web3.py
sudo apt-get install libssl-dev libffi-dev autoconf automake libtool
git clone git@github.com:ethereum/web3.py.git
cd web3.py
pip install -r requirements-dev.txt
pip install -e .[tester]
# install pyethereum
sudo apt-get install libssl-dev build-essential automake pkg-config libtool libffi-dev libgmp-dev libyaml-cpp-dev
git clone https://github.com/ethereum/pyethereum/
cd pyethereum
python setup.py install
```

### 部署节点

#### 部署主节点
```
cd vote_master
# start block chain
pm2 start geth.sh
# start web api
pm2 start web.sh
# show pm2 list
pm2 list
# show nodeInfo
./geth attach http://127.0.0.1:8545
# 控制台内输入
admin.nodeInfo
```
保存nodeInfo中的enode：

```
"enode://7c2222797bc4579e5675d75a4ed6803606f7ea925ffd83ce58712e21488c5a30c107758ac69098e791f4589a23663cfb8484d0f56663e06f4d1b9517f3b685f0@[::]:30101"
```
注意：`[::]`替换为`ip`

更多pm2命令参考：http://pm2.keymetrics.io/docs/usage/quick-start/

#### 部署挖矿节点

```
cd vote_miner
#  初始化挖矿节点
bash init.sh
```
在`data`目录下新建`static-nodes.json`，保存一下内容，注意替换`ip`：
```
["enode://7c2222797bc4579e5675d75a4ed6803606f7ea925ffd83ce58712e21488c5a30c107758ac69098e791f4589a23663cfb8484d0f56663e06f4d1b9517f3b685f0@ip:30101"]
```
```
# 启动节点
pm2 start miner.sh
```
至此，环境部署完毕。

### 智能合约

`smart contracts`下`token contract`为代币智能合约源代码，`abu.js`和`votes.js`为合约部署文件。部署智能合约参考推荐在控制台中部署。



</description>
</item>
<item rdf:about="https://feelncut.com/2018/03/05/103.html">
<title>Geth控制台的进阶使用</title>
<link>https://feelncut.com/2018/03/05/103.html</link>
<dc:date>2018-03-05T23:13:00+08:00</dc:date>
<description>[TOC]

#### 两个参数

```
// js加载路径，默认当前目录
--jspath loadScript 
// 要执行的js命令
--exec value
```

启动Geth时加上`--jspath script --exec "loadScript('help.js')"`

#### 查看所有钱包账户余额

上面两个参数加载help.js到控制台，我们可以在help.js中写一些辅助函数帮助我们提升效率。

```
function checkAllBalances() { 
  var i =0; 
  eth.accounts.forEach( function(e){
    console.log("  eth.accounts["+i+"]: " +  e + " \tbalance: " + web3.fromWei(eth.getBalance(e), "ether") + " ether"); 
    i++; 
  })
};
```

注意： eth.accounts为当前控制台里新建的所有钱包，不是值整个区块链上的钱包地址。

#### 仅在有交易时挖矿


```
function minerWhenTransaction() {

    function checkWork() {
        if (eth.getBlock("pending").transactions.length > 0) {
            if (eth.mining) return;
            console.log("== Pending transactions! Mining...==");
            miner.start(1);
        } else {
            miner.stop();  // This param means nothing
            console.log("== No transactions! Mining stopped.==");
        }
    }

    eth.filter("latest", function(err, block) { checkWork(); });
    eth.filter("pending", function(err, block) { checkWork(); });

    checkWork();

}
```


#### 查看代币余额

```
...
```

当然你还可以实现其他更多辅助功能。</description>
</item>
<item rdf:about="https://feelncut.com/2018/03/05/102.html">
<title>以太坊搭建POW私链及注意事项</title>
<link>https://feelncut.com/2018/03/05/102.html</link>
<dc:date>2018-03-05T23:01:00+08:00</dc:date>
<description>[TOC]

主要参考：https://github.com/ethereum/go-ethereum/wiki/Private-network

### 初始化创世区块

json文件：
```
{
    "config": {
        "chainId": 15,
        "homesteadBlock": 0,
        "eip155Block": 0,
        "eip158Block": 0
    },
    "difficulty": "200000000",
    "gasLimit": "2100000",
    "alloc": {
        "7df9a875a174b3bc565e6424a0050ebc1b2d1d82": { "balance": "300000" },
        "f41c74c9ae680c1aa78f42e5647a62f353b7bdde": { "balance": "400000" }
    }
}
```
chainId最好和主网测试网区别开，difficulty是挖矿难度，可以改小一点，alloc是创世区块预先分配的ETH，确保你知道密钥，否则之后无法使用该钱包。

初始化命令：
```
geth --datadir=data init genesis.json
```
`-datadir`指定区块存储地址。

### 启动节点

命令：
```
geth --identity "myname"  --rpc  --rpccorsdomain "*" --datadir data/ --port "30303"  --rpcapi "db,eth,net,web3,personal,admin,miner"  --networkid 15 console
```
`networkid`最好和`chainId`一致，否则无法使用`MetaMask`。
`--rpc`表示开启json rpc服务，`--rpcapi`表示允许rpc使用哪些API
更多参数参见：https://github.com/ethereum/go-ethereum/wiki/Command-Line-Options

遇到关闭节点后，区块不保存的现象，加上：`--gcmode=archive`即可。

### 使用控制台

通过`console`命令进入控制台后，可能会用到一下命令：

```
// 创建账号：
personal.newAccount('123456')
// 查询账户：
eth.accounts
// 账户赋值给变量：
u1 =eth.accounts[0]
u2 =eth.accounts[1]
// 查询账户余额：
eth.getBalance(u1)
// 显示当前区块：
eth.blockNumber
// 开始挖矿（默认第一个账户得到挖矿收益）：
miner.start()
// 手动指定挖矿收益账户
miner.setEtherbase('0x067D19026e1C15a1b641a191D188542A98f2060e');
// 设定gasPrice
miner.setGasPrice(0x123456);
// 停止挖矿：
miner.stop()
// 解锁账户（获得账户使用权）：
personal.unlockAccount(user1, "123456")
// user1转账3以太币给user2：
eth.sendTransaction({from: u1, to: u2, value: web3.toWei(1,"ether")})
// 查看交易
eth.getTransaction(txhash)
// 查看交易凭证
eth.getTransactionReceipt(txhash)
// 查看txpool
txpool
// 查看nodeInfo
admin.nodeInfo
// 查看已连接节点
admin.peers
```
更多命令参见：https://github.com/ethereum/go-ethereum/wiki/Management-APIs

注意，u1发送转账后必须经过挖矿u2才可以收到ETH。

### 连接节点

A节点通过`admin.nodeInfo`查看节点信息。其中包含了：
```
enode: "enode://44826a5d6a55f88a18298bca4773fca5749cdc3a5c9f308aa7d810e9b31123f3e7c5fba0b1d70aac5308426f47df2a128a6747040a3815cc7dd7167d03be320d@[::]:30303"
```
B节点连接A节点有两种方式：
1.B节点datadir目录下新建`static-nodes.json`，内容：
```
["enode://44826a5d6a55f88a18298bca4773fca5749cdc3a5c9f308aa7d810e9b31123f3e7c5fba0b1d70aac5308426f47df2a128a6747040a3815cc7dd7167d03be320d@ip:30303"]
```
2.B节点控制台下：
```
admin.addPeer("enode://44826a5d6a55f88a18298bca4773fca5749cdc3a5c9f308aa7d810e9b31123f3e7c5fba0b1d70aac5308426f47df2a128a6747040a3815cc7dd7167d03be320d@ip:30303")
```

注意：如果向A节点提交了交易，B节点txpool未收到交易，只需要在A节点开启一下矿工，待B收到txpool之后关闭A节点矿工即可。</description>
</item>
<item rdf:about="https://feelncut.com/2018/03/05/101.html">
<title>以太坊Geth的四种安装方法</title>
<link>https://feelncut.com/2018/03/05/101.html</link>
<dc:date>2018-03-05T18:29:06+08:00</dc:date>
<description>[TOC]

详细可参考：https://github.com/ethereum/go-ethereum/wiki/Building-Ethereum

安装最简单方便的方法为`二进制安装`，其次`PPA安装`。

### 二进制安装

官方提供了编译好的二进制安装包，直接下载即可使用。Linux下可以将`Geth`所在目录添加到环境变量，或者直接`sudo mv Geth /usr/bin`。

下载地址：https://geth.ethereum.org/downloads/

### Ubuntu下通过PPA安装

```
sudo apt-get install software-properties-common
sudo add-apt-repository -y ppa:ethereum/ethereum
sudo apt-get update
sudo apt-get install ethereum
```

### 源代码安装

通过golang编译源代码：

```
sudo apt-get install -y build-essential golang
cd go-ethereum
make geth
```
编译完成后在目录`build/bin/geth`下可以看到编译好的Geth。

### 通过docker安装

Geth不像Hyperledger安装这么麻烦，不建议docker安装，如有需要，参考：https://github.com/ethereum/go-ethereum/wiki/Running-in-Docker</description>
</item>
<item rdf:about="https://feelncut.com/2018/03/01/99.html">
<title>投票私链接口示例</title>
<link>https://feelncut.com/2018/03/01/99.html</link>
<dc:date>2018-03-01T22:19:00+08:00</dc:date>
<description>[TOC]

### 获取区块数

请求地址：`/getBlockNumber`
请求参数：无
请求方式：Get
描述：获取当前区块数目
返回示例：
```
{
  "data": 3, 
  "status": 1
}
```
### 获取钱包
请求地址：`/getWallet`
请求参数：无
请求方式：Get
描述：获取一个钱包，返回私钥和钱包地址
返回示例：
```
{
  "data": {
    "address": "0x58BE33a0bf45aE93328b3e3A48fA28Aac49467Cf", 
    "key": "0x2d5a08589520c238ca5a738c2b47831cf6a02c1e22d3383d7e6ea097b6a85454"
  }, 
  "status": 1
}
```

### 获取区块详情

请求地址：`/getBlock/`
请求参数：数块number或者区块hash
请求方式：Get
描述：获取区块详情，包含改区块上所含交易的hash
返回示例：
```
{
  "data": {
    "hash": "0xe1fc53a54d1b820dcf288e180921c6bb6dcbcace1041f716dd1ea9fdb12b7a2a", 
    "number": 1, 
    "parentHash": "0xf89492f41ba3204f3383449944e79268daf2ef1698b15f66d00090a2fdc811ab", 
    "timestamp": 1519867811, 
    "transactions": [
      "0xad64be84ff9fff572a4c07852428cd96e9227df252cc718e7cc7cbaf363c4e62"
    ]
  }, 
  "status": 1
}
```

### 发起交易

请求地址：`/transfer`
请求参数：

| 参数名  |参数说明   |参数示例   |
| ------------ | ------------ | ------------ |
|  from_key | 发送人私钥  | 0xabcd...  |
|   to_address | 接受方地址   |  0xabcd...  |
|   tyoe |交易类型    |   `ABU`或者`VOTE`|
| value | 交易数量 | 100000|
请求方式：Post
描述：发起交易，返回交易hash
返回示例：
```
{
  "data": {
   "hash": "0x9943b69ea18609b165dd27504cee4dcf01e791471fa17ca59b91ed46c0c25117"
  },
  "status": 1
}
```

### 查询交易

请求地址：`/getTransation/`
请求参数：交易hash
请求方式：Get
描述：获取交易详情
返回示例：
```
{
  "data": {
    "blockHash": "0xc1a68637fe6453acb5b9244e7f65c6159a8929bbf6da29d5cb0464f12e749a73", 
    "blockNumber": 4, 
    "from": "0x4a244BF6834f7569A726DB8ec0D3B24D31ce52c3", 
    "hash": "0x9943b69ea18609b165dd27504cee4dcf01e791471fa17ca59b91ed46c0c25117", 
    "timestamp": 1519914433, 
    "to": "0xc997450005525b123f4274221af5c55d3def466b", 
    "token_type": "VOTES", 
    "value": 10
  }, 
  "status": 1
}
```

### 获取余额

请求地址：`/getBalance/`
请求参数：钱包地址
请求方式：Get
描述：获取钱包余额
返回示例：
```
{
  "data": {
    "ABU": 0, 
    "VOTE": 20
  }, 
  "status": 1
}
```</description>
</item>
<item rdf:about="https://feelncut.com/2018/03/01/98.html">
<title>Ubuntu下通过ssh别名快速连接远程服务器以及传输文件</title>
<link>https://feelncut.com/2018/03/01/98.html</link>
<dc:date>2018-03-01T11:16:00+08:00</dc:date>
<description>[TOC]

###  本机公钥写入服务器
生成密钥对之后把公钥写入服务器`cat id_dsa.pub >> ~/.ssh/authorized_keys `

### 修改本机ssh配置
`/etc/ssh/ssh_config`
添加
```
Host qcloud
    HostName 123.x.x.x
    Port 22
    User ubuntu
    # IdentityFile  ~/.ssh/id_rsa.pub
    IdentitiesOnly yes
```

### 连接ssh

`ssh qcloud`

### 使用scp

`scp /path/file qcloud:path/file`</description>
</item>
</rdf:RDF>